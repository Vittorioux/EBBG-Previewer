# --------------------------------------------------------------------------------------------------------------------------



# EarthBound Battle Background Previewer v1.0

# https://github.com/Vittorioux/EBBG-Previewer

# Logic file.



# -------------------------------------------------------- Imports ---------------------------------------------------------



import constants as c

import os
import sys
import tempfile
import struct

import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox

from PIL import Image, ImageTk, UnidentifiedImageError

import subprocess
from subprocess import Popen



# ------------------------------------------------------- Functions --------------------------------------------------------



# -----------------------------------------------------------
# ------------------- Open about window ---------------------
# -----------------------------------------------------------

def open_about_window(root):
	about = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	about.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	about.title("About")
	about.geometry(f"600x300+{root.winfo_x()+20}+{root.winfo_y()+20}")
	about.grab_set()
	
	scrollbar = tk.Scrollbar(about)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(about, wrap="word", yscrollcommand=scrollbar.set, height=5)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	text.insert("1.0", c.ABOUT_TEXT)
	
	text.config(state="disabled")
	
	about.protocol("WM_DELETE_WINDOW", about.destroy)

# --------------------------------------------------------------------
# ------------------- Browse file and fill field ---------------------
# --------------------------------------------------------------------

def browse_file(field):
	route = filedialog.askopenfilename()
	
	if route:
		field.delete(0, tk.END)
		field.insert(0, route)
	
	# Update preview images.
	
	

# --------------------------------------------------------------------
# ------------------------- Write data file --------------------------
# --------------------------------------------------------------------

def write_data_file(file, fields, root):
	settings = {name: fields[name].get() for name in c.t_field_names}     # Fetch field values.
	
	lines = [
		"# DO NOT EDIT THIS FILE",
		"",
		"width: " + str(root.winfo_width()),   # These four names are hardcoded.
		"height: " + str(root.winfo_height()),
		"x_pos: " + str(root.winfo_x()),
		"y_pos: " + str(root.winfo_y()),
		"",
	]
	
	for field in c.t_field_names:
		lines.append(field + ": " + settings.get(field, ""))
	
	data = "\n".join(lines)
	
	with open(file, "w") as data_f:
		data_f.write(data)

# --------------------------------------------------------------------
# -------------------------- Read data file --------------------------
# --------------------------------------------------------------------

def read_data_file(file):
	
	settings = {}
	
	# Parse the file.
	
	with open(file, 'r', encoding='utf-8') as data_f:
		for line in data_f:
			line = line.strip()
			
			if not line or line.startswith('#'):
				continue
			
			if ':' in line:
				key, value = line.split(':', 1)
				value = value.strip()
				
			settings[key.strip()] = int(value) if value.isdigit() else value
	
	return settings

# --------------------------------------------------------------------
# -------------------------- Read data file --------------------------
# --------------------------------------------------------------------

def update_preview(fields, img_frame_1, img_frame_2, *args):
	routes = [fields["setting_bg1"].get(), fields["setting_bg2"].get()]
	frames = [img_frame_1, img_frame_2]
	
	for i in range(2):
		for widget in frames[i].winfo_children():
			widget.destroy()
		
		if not routes[i]:
			tk.Label(frames[i], text="<NO IMG>").pack(expand=True)
			continue
		
		if not os.path.isfile(routes[i]):
			tk.Label(frames[i], text="<NOT FOUND>").pack(expand=True)
			continue
		
		try:
			img = Image.open(routes[i])
			img.thumbnail((128, 128))
			photo_img = ImageTk.PhotoImage(img)
			label_img = tk.Label(frames[i], image=photo_img)
			label_img.image = photo_img
			label_img.pack()
		except (UnidentifiedImageError, OSError):
			tk.Label(frames[i], text="<NOT FOUND>").pack(expand=True)

# --------------------------------------------------------------------
# --------------------------- Write to ROM ---------------------------
# --------------------------------------------------------------------

def execute(fields, check_vars):
	
	# Fetch files.
	
	route_rom = fields["setting_rom"].get()
	route_bg1 = fields["setting_bg1"].get()
	route_bg2 = fields["setting_bg2"].get()
	
	# Fetch console.
	
	console = fields["console"]
	
	# Validate ROM.
	
	# File doesn't exist.
	if not os.path.exists(route_rom):
		raise_error(console, 0)
		return
	
	# File too small.
	if os.path.getsize(route_rom) < 0x101CA:
		raise_error(console, 1)
		return
	
	# Raise error if the image for BG Layer 1 wasn't specified/doesn't exist.
	if not os.path.exists(route_bg1):
		raise_error(console, 2)
		return
	
	# Raise error if the image for BG Layer 2 was specified the file wasn't found.
	if route_bg2 != "" and not os.path.exists(route_bg2):
		raise_error(console, 3)
		return
	
	rom_info = (0x45, 0x41, 0x52, 0x54, 0x48, 0x20, 0x42, 0x4f, 0x55, 0x4E, 0x44)
	
	with open(route_rom, "r+b") as rom:
		header = 0x000
		
		rom.seek(0xFFC0)
		
		for byte in rom_info:
			if rom.read(1)[0] != byte:
				header = 0x200
				
				rom.seek(0xFFC0+header)
				
				for byte in rom_info:
					if rom.read(1)[0] != byte:
						raise_error(console, 1)
						return
		
		# Give little warning that the ROM will be modified.
		
		rom.seek(0x2FFFF)
		
		if rom.read(1)[0] != 0xEA:
			if not messagebox.askokcancel("Warning", "The ROM will be modified to preview the battle background/s.\n\nContinue?"):
				raise_error(console, 5)
				return
		
		# Convert the images to the right BGR555 format.
		
		imgs = [Image.open(route_bg1)]
		
		if route_bg2 != "":
			imgs.append(Image.open(route_bg2))
		
		for idx, img in enumerate(imgs):
			if img.mode == 'P':
				pal = img.getpalette()
				new_pal = []
				
				for i in range(0, len(pal), 3):
					r = round_to_nearest_8(pal[i])
					g = round_to_nearest_8(pal[i+1])
					b = round_to_nearest_8(pal[i+2])
					new_pal.extend([r, g, b])
				
				img.putpalette(new_pal)
				img.save(c.TEMP_IMGS_OUT[idx])
			
			else:
				raise_error(console, 6)
		
		# Show an error message by default, you shouldn't see it if the process goes fine.
		
		raise_error(console, -1)
		
		# Run SuperFamiconV to extract data and Inhal to compress it and insert it.
		
		sfcv_path = os.path.join(sys._MEIPASS, "superfamiconv")
		inhal_path = os.path.join(sys._MEIPASS, "inhal")
		
		# Run SuperFamiconV for BG1.
		
		commands = [
			[sfcv_path, "palette", "-i", c.TEMP_IMG_OUT_1, "-d", c.TEMP_PALETTE_OUT_1, "-R", "-W", "8", "-H", "8"],
			[sfcv_path, "tiles", "-i", c.TEMP_IMG_OUT_1, "-d", c.TEMP_TILES_OUT_1, "-p", c.TEMP_PALETTE_OUT_1, "-B", fields["setting_bpp_bg1"].get(), "-W", "8", "-H", "8"],
			[sfcv_path, "map", "-i", c.TEMP_IMG_OUT_1, "-p", c.TEMP_PALETTE_OUT_1, "-t", c.TEMP_TILES_OUT_1, "-d", c.TEMP_TILEMAP_OUT_1, "-B", fields["setting_bpp_bg1"].get(), "-W", "8", "-H", "8"]
		]
		
		for command in commands:
			result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
			
			# If there was a SuperFamiconV error, show it through the console.
			
			if result.returncode != 0:
				console.config(state="normal")
				console.delete("1.0", "end")
				console.insert("1.0", "[!] Trying to insert a 2BPP layer when the image is 4BPP?\n" + f"[!] SuperFamiconV: {result.stderr}")
				console.config(state="disabled")
				return
		
		# Insert palette in ROM.
		
		with open(c.TEMP_PALETTE_OUT_1, "rb") as f:
			pal_data = f.read()
		
		rom.seek(c.PAL_25_OFFSET - c.BANK_C0_OFFSET + header)
		rom.write(pal_data)
		
		# Compress tiles and tilemap with Inhal and insert them.
		
		commands = [
			[inhal_path, "-fast", c.TEMP_TILES_OUT_1, route_rom, f"{c.GFX_25_OFFSET - c.BANK_C0_OFFSET + header}"],
			[inhal_path, "-fast", c.TEMP_TILEMAP_OUT_1, route_rom, f"{c.ARR_25_OFFSET - c.BANK_C0_OFFSET + header}"]
		]
		
		for command in commands:
			result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
			
			if result.returncode != 0:
				console.config(state="normal")
				console.delete("1.0", "end")
				console.insert("1.0", f"[!] Inhal: {result.stderr}")
				console.config(state="disabled")
				return
		
		# If there is a BG2 image, do the same for BG2.
		
		if route_bg2 != "":
			commands = [
				[sfcv_path, "palette", "-i", c.TEMP_IMG_OUT_2, "-d", c.TEMP_PALETTE_OUT_2, "-R", "-W", "8", "-H", "8"],
				[sfcv_path, "tiles", "-i", c.TEMP_IMG_OUT_2, "-d", c.TEMP_TILES_OUT_2, "-p", c.TEMP_PALETTE_OUT_2, "-B", fields["setting_bpp_bg2"].get(), "-W", "8", "-H", "8"],
				[sfcv_path, "map", "-i", c.TEMP_IMG_OUT_2, "-p", c.TEMP_PALETTE_OUT_2, "-t", c.TEMP_TILES_OUT_2, "-d", c.TEMP_TILEMAP_OUT_2, "-B", fields["setting_bpp_bg2"].get(), "-W", "8", "-H", "8"]
			]
			
			for command in commands:
				result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
				
				# If there was a SuperFamiconV error, show it through the console.
				
				if result.returncode != 0:
					console.config(state="normal")
					console.delete("1.0", "end")
					console.insert("1.0", "[!] Trying to insert a 2BPP layer when the image is 4BPP?\n" + f"[!] SuperFamiconV: {result.stderr}")
					console.config(state="disabled")
					return
			
			# Insert palette in ROM.
		
			with open(c.TEMP_PALETTE_OUT_2, "rb") as f:
				pal_data = f.read()
			
			rom.seek(c.PAL_50_OFFSET - c.BANK_C0_OFFSET + header)
			rom.write(pal_data)
			
			# Compress tiles and tilemap with Inhal and insert them.
			
			commands = [
				[inhal_path, "-fast", c.TEMP_TILES_OUT_2, route_rom, f"{c.GFX_50_OFFSET - c.BANK_C0_OFFSET + header}"],
				[inhal_path, "-fast", c.TEMP_TILEMAP_OUT_2, route_rom, f"{c.ARR_50_OFFSET - c.BANK_C0_OFFSET + header}"]
			]
			
			for command in commands:
				result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
				
				if result.returncode != 0:
					console.config(state="normal")
					console.delete("1.0", "end")
					console.insert("1.0", f"[!] Inhal: {result.stderr}")
					console.config(state="disabled")
					return
		
		# Insert forced bytes.
		
		for insertion in c.forced_rom_insertions:
			rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
			rom.write(bytes(insertion["bytes"]))
		
		# Insert palette cycling settings.
		
		# Assume every setting should be a byte.
		
		for insertion in c.insertions_palette:
			if insertion["field"] == "combobox_idx":
				d = bytes([int(c.CYCLE_TYPE_NAMES.index(fields[insertion["name"]].get()))])
			else:
				d = bytes([int(fields[insertion["name"]].get())])
			
			rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
			rom.write(d)
		
		# Zero out scroll and distortion entries if the boxes are checked.
		
		i = 0
		
		for insertion in c.insertions_check:
			if check_vars[i].get():
				rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
				rom.write(bytes([0x00]))
				
			# Advance in the 'check_vars' list.
			i = i + 1
	
		# Insert scroll entry settings.
		
		# Assume every setting should be fetched from an entry and have a 'short' data type.
		
		for bg in range(2):
			for scr in range(4):
				for insertion in c.insertions_scroll:
					d = struct.pack("<H", int(fields[insertion["name"] + f"_bg{bg+1}_scr{scr+1}"].get()))
					
					rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header + bg*c.SCR_ENTRY_SIZE*4 + scr*c.SCR_ENTRY_SIZE)
					rom.write(d)
	
		# Insert distortion entry settings.
		
		for bg in range(2):
			for dst in range(4):
				for insertion in c.insertions_distortion:
					if insertion["field"] == "combobox_idx":
						# Assume 'byte' data type.
						d = bytes([int(c.DST_TYPE_NAMES.index(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get()))])
					else:
						# Assume 'entry' field type.
						if insertion["type"] == "byte":
							d = bytes([int(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get())])
						else:
							#  Assume 'short' data type.
							d = struct.pack("<H", int(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get()))
					
					rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header + bg*c.DST_ENTRY_SIZE*4 + dst*c.DST_ENTRY_SIZE)
					rom.write(d)
	
	# Delete all temporary files.
	
	os.remove(c.TEMP_IMG_OUT_1)
	
	for file in c.TEMP_BG1_DATA_OUT:
		os.remove(file)
	
	if os.path.exists(c.TEMP_IMG_OUT_2):
		os.remove(c.TEMP_IMG_OUT_2)
		
		for file in c.TEMP_BG2_DATA_OUT:
			if os.path.exists(file):
				os.remove(file)
	
	# Show success in console.
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Execution finished succesfully.")
	console.config(state="disabled")
	
	return

# --------------------------------------------------------------------
# -------------------------- Try to run ROM --------------------------
# --------------------------------------------------------------------

def run_rom(fields):
	
	# Fetch emulator and ROM.
	
	route_emulator = fields["setting_emulator"].get()
	route_rom = fields["setting_rom"].get()
	
	# Fetch console.
	
	console = fields["console"]
	
	if route_emulator == "" or not os.path.exists(route_emulator):
		raise_error(console, 4)
		return
	
	# ROM file doesn't exist.
	if not os.path.exists(route_rom):
		raise_error(console, 0)
		return
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Attempting to run the ROM.")
	console.config(state="disabled")
	Popen([route_emulator, route_rom])
	
	return

# --------------------------------------------------------------------
# ----------------------- Auxiliary functions ------------------------
# --------------------------------------------------------------------

# ------------------------ Round to nearest 8 ------------------------

def round_to_nearest_8(value):
    rounded = round(value / 8) * 8
    return max(0, min(255, rounded))

# -------------------------- Error handler ---------------------------

def raise_error(console, code):
	if code == 0:
		msg = "The specified ROM file doesn't exist."
	elif code == 1:
		msg = "The ROM file does not seem to be a valid EarthBound ROM."
	elif code == 2:
		msg = "The specified image file for the first layer was not found"
	elif code == 3:
		msg = "The specified image file for the second layer was not found"
	elif code == 4:
		msg = "An emulator couldn't be found."
	elif code == 5:
		msg = "The execution was aborted."
	elif code == 6:
		msg = "One or more of the specified image files isn't in indexed palette mode."
	else:
		msg = "An unknown exception occured (check field values or try again)."
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[!] " + msg)
	console.config(state="disabled")
	
	return