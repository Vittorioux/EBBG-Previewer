# --------------------------------------------------------------------------------------------------------------------------



# EarthBound Battle Background Previewer

# https://github.com/Vittorioux/EBBG-Previewer

# Logic file.



# -------------------------------------------------------- Imports ---------------------------------------------------------



import constants as c

import os
import sys
import tempfile
import struct

import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox

from PIL import Image, ImageTk, UnidentifiedImageError

import subprocess
from subprocess import Popen



# ------------------------------------------------------- Functions --------------------------------------------------------



# -----------------------------------------------------------
# ------------------- Open about window ---------------------
# -----------------------------------------------------------

def open_about_window(root):
	about = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	about.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	about.title("About")
	about.geometry(f"600x300+{root.winfo_x()+20}+{root.winfo_y()+20}")
	about.grab_set()
	
	scrollbar = tk.Scrollbar(about)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(about, wrap="word", yscrollcommand=scrollbar.set, height=5)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	text.insert("1.0", c.ABOUT_TEXT)
	
	text.config(state="disabled")
	
	about.protocol("WM_DELETE_WINDOW", about.destroy)

# --------------------------------------------------------------------
# ------------------- Browse file and fill field ---------------------
# --------------------------------------------------------------------

def browse_file(field):
	route = filedialog.askopenfilename()
	
	if route:
		field.delete(0, tk.END)
		field.insert(0, route)

# --------------------------------------------------------------------
# ------------------------- Write data file --------------------------
# --------------------------------------------------------------------

def write_data_file(file, fields, root):
	lines = [
		"# DO NOT EDIT THIS FILE",
		"",
		"# PROGRAM GEOMETRY",
		"",
		"width: " + str(root.winfo_width()),   # These four names are hardcoded.
		"height: " + str(root.winfo_height()),
		"x_pos: " + str(root.winfo_x()),
		"y_pos: " + str(root.winfo_y()),
		"",
		"# TOP FRAME FIELDS",
		""
	]
	
	for key, value in fields.items():
		
		# If the field is a 'Combobox' get the index.
		
		if isinstance(value, ttk.Combobox):
			lines.append(key + ": " + str(value["values"].index(value.get())))
		
		# If the field is an 'Entry' get the value directly ('ttk.Combobox' is also detected as an instance of 'tk.Entry' for some reason).
		
		elif isinstance(value, tk.Entry):
			lines.append(key + ": " + value.get())
		
		# Add a separator after the field for the BG2 image.
		
		if key == c.t_field_names[3]:
			lines.append("\n# MIDDLE FRAME FIELDS\n")
	
	data = "\n".join(lines)
	
	with open(file, "w") as data_f:
		data_f.write(data)

# --------------------------------------------------------------------
# -------------------------- Read data file --------------------------
# --------------------------------------------------------------------

def read_data_file(file):
	
	settings = {}
	
	# Parse the file.
	
	with open(file, 'r', encoding='utf-8') as data_f:
		for line in data_f:
			line = line.strip()
			
			if not line or line.startswith('#'):
				continue
			
			if ':' in line:
				key, value = line.split(':', 1)
				value = value.strip()
				
			settings[key.strip()] = int(value) if value.isdigit() else value
	
	return settings

# --------------------------------------------------------------------
# -------------------- Write fields from data file -------------------
# --------------------------------------------------------------------

def write_data_to_fields(data, fields):
	for key, value in data.items():
		if key in fields:
			
			# If the field is a 'Combobox' set the current selected option based on the read index.
			
			if isinstance(fields[key], ttk.Combobox):
				fields[key].current(value)
				
			# Else, if the field is an 'Entry' insert the value directly ('ttk.Combobox' is also detected as an instance of 'tk.Entry' for some reason).
			
			elif isinstance(fields[key], tk.Entry):
				fields[key].delete(0, tk.END)
				fields[key].insert(0, str(value))

# --------------------------------------------------------------------
# ------------------------- Reset all fields -------------------------
# --------------------------------------------------------------------

def reset_fields(fields, check_vars):
	
	# Give little warning.
	
	if not messagebox.askokcancel("Reset fields", "All setting fields will be reset to 0.\n\nProceed?"):
		return
	
	# Set all checkboxes.
	for var in check_vars:
		var.set(True)
	
	for key, value in fields.items():
		
		if not key in c.t_field_names:
			
			# Handle comboboxes.
			
			if isinstance(value, ttk.Combobox):
				if key == (c.m_field_names_palette[0] + "_bg1"):
					# If the field is the BPP value for the first layer, set it to the second option in the list (4).
					value.current(1)
				else:
					# Else, set the first option in the list.
					value.current(0)
			
			# Handle entries.
			
			elif isinstance(value, tk.Entry):
				value.delete(0, tk.END)
				value.insert(0, "0")
	
	return

# --------------------------------------------------------------------
# ---------------------- Update images preview -----------------------
# --------------------------------------------------------------------

def update_preview(fields, img_frame_1, img_frame_2, *args):
	routes = [fields["setting_bg1"].get(), fields["setting_bg2"].get()]
	frames = [img_frame_1, img_frame_2]
	
	for i in range(2):
		for widget in frames[i].winfo_children():
			widget.destroy()
		
		if not routes[i]:
			tk.Label(frames[i], text="<NO IMG>").pack(expand=True)
			continue
		
		if not os.path.isfile(routes[i]):
			tk.Label(frames[i], text="<NOT FOUND>").pack(expand=True)
			continue
		
		try:
			img = Image.open(routes[i])
			img.thumbnail((128, 128))
			photo_img = ImageTk.PhotoImage(img)
			label_img = tk.Label(frames[i], image=photo_img)
			label_img.image = photo_img
			label_img.pack()
		except (UnidentifiedImageError, OSError):
			tk.Label(frames[i], text="<NOT FOUND>").pack(expand=True)

# --------------------------------------------------------------------
# --------------------------- Write to ROM ---------------------------
# --------------------------------------------------------------------

def execute(fields, check_vars):
	
	# Get base path and assets path.
	
	if getattr(sys, 'frozen', False):
		base_path = os.path.dirname(sys.executable)
	else:
		base_path = os.path.dirname(__file__)
	
	try:
		assets_path = sys._MEIPASS
	except Exception:
		assets_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "assets"))
	
	# Generate paths.
	
	img_1_out_path = os.path.join(base_path, c.TEMP_IMG_OUT_1)
	img_2_out_path = os.path.join(base_path, c.TEMP_IMG_OUT_2)
	img_out_paths = [img_1_out_path, img_2_out_path]
	
	temp_palette_out_1_path = os.path.join(base_path, c.TEMP_PALETTE_OUT_1)
	temp_tiles_out_1_path = os.path.join(base_path, c.TEMP_TILES_OUT_1)
	temp_tilemap_out_1_path = os.path.join(base_path, c.TEMP_TILEMAP_OUT_1)
	temp_bg1_data_out_paths = [temp_palette_out_1_path, temp_tiles_out_1_path, temp_tilemap_out_1_path]
	
	temp_palette_out_2_path = os.path.join(base_path, c.TEMP_PALETTE_OUT_2)
	temp_tiles_out_2_path = os.path.join(base_path, c.TEMP_TILES_OUT_2)
	temp_tilemap_out_2_path = os.path.join(base_path, c.TEMP_TILEMAP_OUT_2)
	temp_bg2_data_out_paths = [temp_palette_out_2_path, temp_tiles_out_2_path, temp_tilemap_out_2_path]
	
	# Fetch files.
	
	route_rom = fields["setting_rom"].get()
	route_bg1 = fields["setting_bg1"].get()
	route_bg2 = fields["setting_bg2"].get()
	
	# Fetch console.
	
	console = fields["console"]
	
	# Validate ROM.
	
	# File doesn't exist.
	if not os.path.exists(route_rom):
		raise_error(console, 0)
		return
	
	# File too small.
	if os.path.getsize(route_rom) < 0x101CA:
		raise_error(console, 1)
		return
	
	# Raise error if the image for BG Layer 1 wasn't specified/doesn't exist.
	if not os.path.exists(route_bg1):
		raise_error(console, 2)
		return
	
	# Raise error if the image for BG Layer 2 was specified the file wasn't found.
	if route_bg2 != "" and not os.path.exists(route_bg2):
		raise_error(console, 3)
		return
	
	rom_info = (0x45, 0x41, 0x52, 0x54, 0x48, 0x20, 0x42, 0x4f, 0x55, 0x4E, 0x44)
	
	with open(route_rom, "r+b") as rom:
		header = 0x000
		
		rom.seek(0xFFC0)
		
		for byte in rom_info:
			if rom.read(1)[0] != byte:
				header = 0x200
				
				rom.seek(0xFFC0+header)
				
				for byte in rom_info:
					if rom.read(1)[0] != byte:
						raise_error(console, 1)
						return
		
		# Give little warning that the ROM will be modified.
		
		rom.seek(0xC2FFFF - c.BANK_C0_OFFSET + header)
		
		if rom.read(1)[0] != 0xEA:
			if not messagebox.askokcancel("Warning", "The ROM will be modified to preview the battle background/s.\n\nContinue?"):
				raise_error(console, 5)
				return
		
		# Convert the images to the right BGR555 format.
		
		imgs = [Image.open(route_bg1)]
		
		if route_bg2 != "":
			imgs.append(Image.open(route_bg2))
		
		for idx, img in enumerate(imgs):
			if img.mode == 'P':
				pal = img.getpalette()
				new_pal = []
				
				for i in range(0, len(pal), 3):
					r = round_to_nearest_8(pal[i])
					g = round_to_nearest_8(pal[i+1])
					b = round_to_nearest_8(pal[i+2])
					new_pal.extend([r, g, b])
				
				img.putpalette(new_pal)
				img.save(img_out_paths[idx])
			
			else:
				raise_error(console, 6)
		
		# Show an error message by default, you shouldn't see it if the process goes fine.
		
		raise_error(console, -1)
		
		# Run SuperFamiconV to extract data and Inhal to compress it and insert it.
		
		sfcv_path = os.path.join(assets_path, "superfamiconv")
		inhal_path = os.path.join(assets_path, "inhal")
		
		# Run SuperFamiconV for BG1.
		
		commands = [
			[sfcv_path, "palette", "-i", img_1_out_path, "-d", temp_palette_out_1_path, "-R", "-W", "8", "-H", "8"],
			[sfcv_path, "tiles", "-i", img_1_out_path, "-d", temp_tiles_out_1_path, "-p", temp_palette_out_1_path, "-B", fields["setting_bpp_bg1"].get(), "-W", "8", "-H", "8"],
			[sfcv_path, "map", "-i", img_1_out_path, "-p", temp_palette_out_1_path, "-t", temp_tiles_out_1_path, "-d", temp_tilemap_out_1_path, "-B", fields["setting_bpp_bg1"].get(), "-W", "8", "-H", "8"]
		]
		
		for command in commands:
			result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
			
			# If there was a SuperFamiconV error, show it through the console.
			
			if result.returncode != 0:
				console.config(state="normal")
				console.delete("1.0", "end")
				console.insert("1.0", "[!] Trying to insert a 2BPP layer when the image is 4BPP?\n" + f"[!] SuperFamiconV: {result.stderr}")
				console.config(state="disabled")
				return
		
		# Insert palette in ROM.
		
		with open(temp_palette_out_1_path, "rb") as f:
			pal_data = f.read()
		
		rom.seek(c.PAL_25_OFFSET - c.BANK_C0_OFFSET + header)
		rom.write(pal_data)
		
		# Compress tiles and tilemap with Inhal and insert them.
		
		commands = [
			[inhal_path, "-fast", temp_tiles_out_1_path, route_rom, f"{c.GFX_25_OFFSET - c.BANK_C0_OFFSET + header}"],
			[inhal_path, "-fast", temp_tilemap_out_1_path, route_rom, f"{c.ARR_25_OFFSET - c.BANK_C0_OFFSET + header}"]
		]
		
		for command in commands:
			result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
			
			if result.returncode != 0:
				console.config(state="normal")
				console.delete("1.0", "end")
				console.insert("1.0", f"[!] Inhal: {result.stderr}")
				console.config(state="disabled")
				return
		
		# If there is a BG2 image, do the same for BG2.
		
		if route_bg2 != "":
			commands = [
				[sfcv_path, "palette", "-i", img_2_out_path, "-d", temp_palette_out_2_path, "-R", "-W", "8", "-H", "8"],
				[sfcv_path, "tiles", "-i", img_2_out_path, "-d", temp_tiles_out_2_path, "-p", temp_palette_out_2_path, "-B", fields["setting_bpp_bg2"].get(), "-W", "8", "-H", "8"],
				[sfcv_path, "map", "-i", img_2_out_path, "-p", temp_palette_out_2_path, "-t", temp_tiles_out_2_path, "-d", temp_tilemap_out_2_path, "-B", fields["setting_bpp_bg2"].get(), "-W", "8", "-H", "8"]
			]
			
			for command in commands:
				result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
				
				# If there was a SuperFamiconV error, show it through the console.
				
				if result.returncode != 0:
					console.config(state="normal")
					console.delete("1.0", "end")
					console.insert("1.0", "[!] Trying to insert a 2BPP layer when the image is 4BPP?\n" + f"[!] SuperFamiconV: {result.stderr}")
					console.config(state="disabled")
					return
			
			# Insert palette in ROM.
		
			with open(temp_palette_out_2_path, "rb") as f:
				pal_data = f.read()
			
			rom.seek(c.PAL_50_OFFSET - c.BANK_C0_OFFSET + header)
			rom.write(pal_data)
			
			# Compress tiles and tilemap with Inhal and insert them.
			
			commands = [
				[inhal_path, "-fast", temp_tiles_out_2_path, route_rom, f"{c.GFX_50_OFFSET - c.BANK_C0_OFFSET + header}"],
				[inhal_path, "-fast", temp_tilemap_out_2_path, route_rom, f"{c.ARR_50_OFFSET - c.BANK_C0_OFFSET + header}"]
			]
			
			for command in commands:
				result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
				
				if result.returncode != 0:
					console.config(state="normal")
					console.delete("1.0", "end")
					console.insert("1.0", f"[!] Inhal: {result.stderr}")
					console.config(state="disabled")
					return
		
		# Insert forced bytes.
		
		for insertion in c.forced_rom_insertions:
			rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
			rom.write(bytes(insertion["bytes"]))
		
		if route_bg2 == "":
			
			# If there is no BG2, don't load it.
			
			rom.seek(c.MENU_BG2_OFFSET - c.BANK_C0_OFFSET + header)
			rom.write(bytes([0x00]))
		
		# Insert palette cycling settings.
		
		# Assume every setting should be a byte.
		
		for insertion in c.insertions_palette:
			if insertion["field"] == "combobox_idx":
				d = bytes([int(c.CYCLE_TYPE_NAMES.index(fields[insertion["name"]].get()))])
			else:
				d = bytes([int(fields[insertion["name"]].get())])
			
			rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
			rom.write(d)
		
		# Zero out scroll and distortion entries if the boxes are checked.
		
		i = 0
		
		for insertion in c.insertions_check:
			if check_vars[i].get():
				rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
				rom.write(bytes([0x00]))
				
			# Advance in the 'check_vars' list.
			i = i + 1
	
		# Insert scroll entry settings.
		
		# Assume every setting should be fetched from an entry and have a 'short' data type.
		
		for bg in range(2):
			for scr in range(4):
				for insertion in c.insertions_scroll:
					d = struct.pack("<H", int(fields[insertion["name"] + f"_bg{bg+1}_scr{scr+1}"].get()))
					
					rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header + bg*c.SCR_ENTRY_SIZE*4 + scr*c.SCR_ENTRY_SIZE)
					rom.write(d)
	
		# Insert distortion entry settings.
		
		for bg in range(2):
			for dst in range(4):
				for insertion in c.insertions_distortion:
					if insertion["field"] == "combobox_idx":
						# Assume 'byte' data type.
						d = bytes([int(c.DST_TYPE_NAMES.index(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get()))])
					else:
						# Assume 'entry' field type.
						if insertion["type"] == "byte":
							d = bytes([int(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get())])
						else:
							#  Assume 'short' data type.
							d = struct.pack("<H", int(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get()))
					
					rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header + bg*c.DST_ENTRY_SIZE*4 + dst*c.DST_ENTRY_SIZE)
					rom.write(d)
	
	# Delete all temporary files.
	
	os.remove(img_1_out_path)
	
	for file in temp_bg1_data_out_paths:
		os.remove(file)
	
	if os.path.exists(img_2_out_path):
		os.remove(img_2_out_path)
		
		for file in temp_bg2_data_out_paths:
			if os.path.exists(file):
				os.remove(file)
	
	# Show success in console.
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Execution finished succesfully.")
	console.config(state="disabled")
	
	return

# --------------------------------------------------------------------
# -------------------------- Try to run ROM --------------------------
# --------------------------------------------------------------------

def run_rom(fields):
	
	# Fetch emulator and ROM.
	
	route_emulator = fields["setting_emulator"].get()
	route_rom = fields["setting_rom"].get()
	
	# Fetch console.
	
	console = fields["console"]
	
	if route_emulator == "" or not os.path.exists(route_emulator):
		raise_error(console, 4)
		return
	
	# ROM file doesn't exist.
	if not os.path.exists(route_rom):
		raise_error(console, 0)
		return
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Attempting to run the ROM.\n[o] Hold Y in-game to pause the animation, press L to switch between letterbox sizes.")
	console.config(state="disabled")
	Popen([route_emulator, route_rom])
	
	return

# --------------------------------------------------------------------
# ----------------------- Auxiliary functions ------------------------
# --------------------------------------------------------------------

# ------------------------ Round to nearest 8 ------------------------

def round_to_nearest_8(value):
    rounded = round(value / 8) * 8
    return max(0, min(255, rounded))

# -------------------------- Error handler ---------------------------

def raise_error(console, code):
	if code == 0:
		msg = "The specified ROM file doesn't exist."
	elif code == 1:
		msg = "The ROM file does not seem to be a valid EarthBound ROM."
	elif code == 2:
		msg = "The specified image file for the first layer was not found"
	elif code == 3:
		msg = "The specified image file for the second layer was not found"
	elif code == 4:
		msg = "An emulator couldn't be found."
	elif code == 5:
		msg = "The execution was aborted."
	elif code == 6:
		msg = "One or more of the specified image files isn't in indexed palette mode."
	else:
		msg = "An unknown exception occured (check field values or try again)."
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[!] " + msg)
	console.config(state="disabled")
	
	return