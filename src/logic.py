# --------------------------------------------------------------------------------------------------------------------------



# EarthBound Battle Background Previewer

# https://github.com/Vittorioux/EBBG-Previewer

# Logic file.



# -------------------------------------------------------- Imports ---------------------------------------------------------



import constants as c
import entries as e

import os
import sys
import tempfile
import struct

import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox

from PIL import Image, ImageTk, UnidentifiedImageError

import subprocess
from subprocess import Popen



# ------------------------------------------------------- Functions --------------------------------------------------------



# -----------------------------------------------------------
# ------------------- Open about window ---------------------
# -----------------------------------------------------------

def open_about_window(root):
	about = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	about.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	about.title("About")
	about.geometry(f"600x300+{root.winfo_x()+20}+{root.winfo_y()+20}")
	about.grab_set()
	
	scrollbar = tk.Scrollbar(about)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(about, wrap="word", yscrollcommand=scrollbar.set, height=5)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	text.insert("1.0", c.ABOUT_TEXT)
	
	text.config(state="disabled")
	
	about.protocol("WM_DELETE_WINDOW", about.destroy)

# --------------------------------------------------------------------
# ------------------- Browse file and fill field ---------------------
# --------------------------------------------------------------------

def browse_file(field):
	route = filedialog.askopenfilename()
	
	if route:
		field.delete(0, tk.END)
		field.insert(0, route)

# --------------------------------------------------------------------
# ------------------ Browse folder and fill field --------------------
# --------------------------------------------------------------------

def browse_directory(field):
	route = filedialog.askdirectory()
	
	if route:
		field.delete(0, tk.END)
		field.insert(0, route)

# --------------------------------------------------------------------
# ------------------------- Write data file --------------------------
# --------------------------------------------------------------------

def write_data_file(file, fields, check_vars, root):
	lines = [
		"# DO NOT EDIT THIS FILE",
		"",
		"# PROGRAM GEOMETRY",
		"",
		"width: " + str(root.winfo_width()),   # These four names are hardcoded.
		"height: " + str(root.winfo_height()),
		"x_pos: " + str(root.winfo_x()),
		"y_pos: " + str(root.winfo_y()),
		"",
		"# TOP FRAME FIELDS",
		""
	]
	
	for key, value in fields.items():
		
		# If the field is a 'Combobox' get the index.
		
		if isinstance(value, ttk.Combobox):
			lines.append(key + ": " + str(value["values"].index(value.get())))
		
		# If the field is an 'Entry' get the value directly ('ttk.Combobox' is also detected as an instance of 'tk.Entry' for some reason).
		
		elif isinstance(value, tk.Entry):
			lines.append(key + ": " + value.get())
		
		# Add a separator after the field for the enemy group.
		
		if key == c.t_field_names[4]:
			lines.append("\n# MIDDLE FRAME FIELDS\n")
	
	lines.append("")
	
	check_vars_states = [check_var.get() for check_var in check_vars]
	
	lines.append(f"check_vars: {check_vars_states}")
	
	data = "\n".join(lines)
	
	with open(file, "w") as data_f:
		data_f.write(data)

# --------------------------------------------------------------------
# -------------------------- Read data file --------------------------
# --------------------------------------------------------------------

def read_data_file(file):
	
	settings = {}
	
	# Parse the file.
	
	with open(file, 'r', encoding='utf-8') as data_f:
		for line in data_f:
			line = line.strip()
			
			if not line or line.startswith('#'):
				continue
			
			if ':' in line:
				key, value = line.split(':', 1)
				value = value.strip()
				
			settings[key.strip()] = int(value) if value.isdigit() else value
	
	return settings

# --------------------------------------------------------------------
# -------------------- Write fields from data file -------------------
# --------------------------------------------------------------------

def write_data_to_fields(data, fields, check_vars):
	for key, value in data.items():
		if key in fields:
			
			# If the field is a 'Combobox' set the current selected option based on the read index.
			
			if isinstance(fields[key], ttk.Combobox):
				fields[key].current(value)
				
			# Else, if the field is an 'Entry' insert the value directly ('ttk.Combobox' is also detected as an instance of 'tk.Entry' for some reason).
			
			elif isinstance(fields[key], tk.Entry):
				fields[key].delete(0, tk.END)
				fields[key].insert(0, str(value))
		
		# Set 'Checkbutton' states.
		
		elif key == "check_vars":
			states = [True if 'True' in state else False for state in value.split(', ')]
			
			for var, state in zip(check_vars, states):
				var.set(state)

# --------------------------------------------------------------------
# ------------------------- Reset all fields -------------------------
# --------------------------------------------------------------------

def reset_fields(fields, check_vars):
	
	# Give little warning.
	
	if not messagebox.askokcancel("Reset fields", "All setting fields will be reset to 0.\n\nProceed?"):
		return
	
	# Reset enemy group.
	fields[c.t_field_names[4]].delete(0, tk.END)
	fields[c.t_field_names[4]].insert(0, "1")
	
	# Set all checkboxes.
	for var in check_vars:
		var.set(True)
	
	for key, value in fields.items():
		
		if not key in c.t_field_names:
			
			# Handle comboboxes.
			
			if isinstance(value, ttk.Combobox):
				if key == (c.m_field_names_palette[0] + "_bg1"):
					# If the field is the BPP value for the first layer, set it to the second option in the list (4).
					value.current(1)
				else:
					# Else, set the first option in the list.
					value.current(0)
			
			# Handle entries.
			
			elif isinstance(value, tk.Entry):
				value.delete(0, tk.END)
				value.insert(0, "0")
	
	return

# --------------------------------------------------------------------
# -------------- Write fields from entry (open window) ---------------
# --------------------------------------------------------------------

def load_entry_win(fields, check_vars, root):
	
	# Open new window.
	
	window = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	window.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	window.title("Load vanilla entry")
	window.geometry(f"300x100+{root.winfo_x()+round(root.winfo_width()/2)-150}+{root.winfo_y()+round(root.winfo_height()/2)-50}")
	window.grab_set()
	
	container = tk.Frame(window)
	container.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
	
	container.columnconfigure(0, weight=1)
	
	entries_list = []
	
	for idx, entry in enumerate(e.bgs):
		entries_list.append(f"{idx}")
	
	combobox = ttk.Combobox(container, textvariable=tk.StringVar(), values=entries_list, state="readonly")
	combobox.grid(row=0, column=0, pady=5, sticky="ew")
	combobox.current(0)
	combobox.focus_set()
	
	container = tk.Frame(window)
	container.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
	
	container.columnconfigure(0, weight=1)
	container.columnconfigure(1, weight=1)
	
	button = tk.Button(container, text="Load into BG1", command=lambda: load_entry(1, int(combobox.get()), fields, check_vars))
	button.grid(row=0, column=0, pady=5)
	
	button = tk.Button(container, text="Load into BG2", command=lambda: load_entry(2, int(combobox.get()), fields, check_vars))
	button.grid(row=0, column=1, pady=5)
	
	window.grid_columnconfigure(0, weight=1)
	
	window.protocol("WM_DELETE_WINDOW", window.destroy)
	
	return

# --------------------------------------------------------------------
# --------------------- Write fields from entry ----------------------
# --------------------------------------------------------------------

def load_entry(layer, entry, fields, check_vars):
	
	# Fetch console.
	
	console = fields["console"]
	
	# Iterate through the bg entry.
	
	for idx, bg_value in enumerate(e.bgs[entry]):
		
		# Set 'Palettes' settings.
		
		if idx < 7:
			if idx < 2:
				fields[c.m_field_names_palette[idx] + f"_bg{layer}"].current(bg_value)
			else:
				fields[c.m_field_names_palette[idx] + f"_bg{layer}"].delete(0, tk.END)
				fields[c.m_field_names_palette[idx] + f"_bg{layer}"].insert(0, str(bg_value))
		
		# Set 'Scroll' settings.
		
		elif idx < 11:
			scr = idx - 6
			
			if bg_value == 0:
				check_vars[scr - 1 + 8 * (layer - 1)].set(True)
			else:
				check_vars[scr - 1 + 8 * (layer - 1)].set(False)
			
			for i, scr_value in enumerate(e.scrolls[bg_value]):
				fields[c.m_field_names_scroll[i+1] + f"_bg{layer}" + f"_scr{scr}"].delete(0, tk.END)
				fields[c.m_field_names_scroll[i+1] + f"_bg{layer}" + f"_scr{scr}"].insert(0, str(scr_value))
		
		# Set 'Distortion' settings.
		
		elif idx < 15:
			dst = idx - 10
			
			if bg_value == 0:
				check_vars[dst + 3 + 8 * (layer - 1)].set(True)
			else:
				check_vars[dst + 3 + 8 * (layer - 1)].set(False)
			
			for i, dst_value in enumerate(e.distortions[bg_value]):
				if isinstance(fields[c.m_field_names_distortion[i+1] + f"_bg{layer}" + f"_dst{dst}"], ttk.Combobox):
					fields[c.m_field_names_distortion[i+1] + f"_bg{layer}" + f"_dst{dst}"].current(dst_value)
				else:
					# Assume tk.Entry type:
					
					fields[c.m_field_names_distortion[i+1] + f"_bg{layer}" + f"_dst{dst}"].delete(0, tk.END)
					fields[c.m_field_names_distortion[i+1] + f"_bg{layer}" + f"_dst{dst}"].insert(0, str(dst_value))
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Succesfully inserted vanilla background " + f"{entry}" + " settings into BG" + f"{layer}.")
	console.config(state="disabled")
	
	return

# --------------------------------------------------------------------
# ------------- Show fields in YML format (open window) --------------
# --------------------------------------------------------------------
# ------------------- The code here is pretty bad --------------------
# --------------------------------------------------------------------

def yml_format_win(fields, check_vars, root):
	
	# Open new window.
	
	window = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	window.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	window.title("CoilSnake YML format")
	window.geometry(f"700x400+{root.winfo_x()+round(root.winfo_width()/2)-350}+{root.winfo_y()+round(root.winfo_height()/2)-200}")
	window.grab_set()
	
	notebook = ttk.Notebook(window)
	notebook.pack(expand=True, fill="both")
	
	# Add tabs.
	
	bg_tab = tk.Frame(notebook)
	notebook.add(bg_tab, text="bg_data_table.yml")
	
	scroll_tab = tk.Frame(notebook)
	notebook.add(scroll_tab, text="bg_scrolling_table.yml")
	
	distortion_tab = tk.Frame(notebook)
	notebook.add(distortion_tab, text="bg_distortion_table.yml")
	
	# Add 'bg_data_table' entries.
	
	scrollbar = tk.Scrollbar(bg_tab)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(bg_tab, wrap="word", yscrollcommand=scrollbar.set, height=5)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	lines = []
	
	for bg in range(2):
		lines.append(f"# BG{bg+1}")
		lines.append("BG_NUM:")
		
		for idx, yml_key in enumerate(c.yml_bg_data):
			line = f"  {yml_key}: "
			
			if idx in range(1, 5):
				if not check_vars[idx + 3 + 8 * bg].get():
					line += f"BG{bg+1}_DST{idx}"
				else:
					line += "0"
			elif idx in range(11, 15):
				if not check_vars[idx - 11 + 8 * bg].get():
					line += f"BG{bg+1}_SCR{idx - 10}"
				else:
					line += "0"
			else:
				if idx == 0:
					line += f"{fields[c.m_field_names_palette[0] + f"_bg{bg+1}"].get()}"
				elif idx == 5:
					line += f"{c.yml_cycle_type_names[c.CYCLE_TYPE_NAMES.index(fields[c.m_field_names_palette[1] + f"_bg{bg+1}"].get())]}"
				elif idx in range(6, 11):
					line += f"{fields[c.m_field_names_palette[idx-4] + f"_bg{bg+1}"].get()}"
			
			lines.append(line)
		
		lines.append("")
		
	yml_entry = "\n".join(lines)
		
	text.insert("1.0", yml_entry)
	
	text.config(state="disabled")
		
	# Add 'bg_scrolling' entries.
	
	scrollbar = tk.Scrollbar(scroll_tab)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(scroll_tab, wrap="word", yscrollcommand=scrollbar.set, height=5)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	lines = []
	
	for bg in range(2):
		
		lines.append(f"# BG {bg+1}")
		
		for i in range(4):
			if not check_vars[i + 8 * bg].get():
				lines.append(f"BG{bg+1}_SCR{i+1}:")
				
				for idx, yml_key in enumerate(c.yml_bg_scrolling):
					line = f"  {yml_key}: "
					
					line += f"{fields[c.m_field_names_scroll[idx + 1] + f"_bg{bg+1}_scr{i + 1}"].get()}"
					
					lines.append(line)
				
				lines.append("")
		
	yml_entry = "\n".join(lines)
	
	text.insert("1.0", yml_entry)
	
	text.config(state="disabled")
	
	# Add 'bg_distortion' entries.
	
	scrollbar = tk.Scrollbar(distortion_tab)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(distortion_tab, wrap="word", yscrollcommand=scrollbar.set, height=5)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	lines = []
	
	for bg in range(2):
		
		lines.append(f"# BG {bg+1}")
		
		for i in range(4):
			if not check_vars[i + 4 + 8 * bg].get():
				lines.append(f"BG{bg+1}_DST{i+1}:")
				
				for idx, yml_key in enumerate(c.yml_bg_distortion):
					line = f"  {yml_key}: "
					
					if idx in range(0, 4):
						line += f"{fields[c.m_field_names_distortion[idx+2] + f"_bg{bg+1}_dst{i+1}"].get()}"
					elif idx == 4:
						line += f"{fields[c.m_field_names_distortion[7] + f"_bg{bg+1}_dst{i+1}"].get()}"
					elif idx == 5:
						line += f"{c.yml_distortion_type_names[c.DST_TYPE_NAMES.index(fields[c.m_field_names_distortion[1] + f"_bg{bg+1}_dst{i+1}"].get())]}"
					elif idx == 6:
						line += f"{fields[c.m_field_names_distortion[10] + f"_bg{bg+1}_dst{i+1}"].get()}"
					elif idx == 7:
						line += f"{fields[c.m_field_names_distortion[6] + f"_bg{bg+1}_dst{i+1}"].get()}"
					elif idx in range(8, 10):
						line += f"{fields[c.m_field_names_distortion[idx] + f"_bg{bg+1}_dst{i+1}"].get()}"
					
					lines.append(line)
				
				lines.append("")
	
	yml_entry = "\n".join(lines)
	
	text.insert("1.0", yml_entry)
	
	text.config(state="disabled")
	
	window.protocol("WM_DELETE_WINDOW", window.destroy)
	
	return

# --------------------------------------------------------------------
# ------------------- Load from YML (open window) --------------------
# --------------------------------------------------------------------

def load_yml_win(fields, check_vars, root):
	
	# Open new window.
	
	window = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	window.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	window.title("Load from CoilSnake YML format")
	window.geometry(f"700x400+{root.winfo_x()+round(root.winfo_width()/2)-350}+{root.winfo_y()+round(root.winfo_height()/2)-200}")
	window.grab_set()
	
	window_top_frame = tk.Frame(window, height=20)
	window_top_frame.pack(side="top", fill="x")
	
	window_middle_frame = tk.Frame(window, height=5)
	window_middle_frame.pack(side="top", fill="x")
	
	window_bottom_frame = tk.Frame(window, height=15)
	window_bottom_frame.pack(side="top", fill="x")
	
	controls_frame = tk.Frame(window_bottom_frame)
	controls_frame.pack(expand=True)
	
	scrollbar = tk.Scrollbar(window_top_frame)
	scrollbar.pack(side="right", fill="y")
	
	text = tk.Text(window_top_frame, wrap="word", yscrollcommand=scrollbar.set, height=18)
	text.pack(fill="both", expand=True)
	
	scrollbar.config(command=text.yview)
	
	structure_type = None
	
	status_label = tk.Label(window_middle_frame, text="", anchor="w")
	status_label.pack(fill="x", padx=10, pady=10)
	
	bg_slot_var = tk.StringVar()
	bg_slot_combo = ttk.Combobox(controls_frame, textvariable=bg_slot_var, state="readonly", width=5)
	bg_slot_combo.pack(side="left", padx=5, pady=5)
	
	slot_var = tk.StringVar()
	slot_combo = ttk.Combobox(controls_frame, textvariable=slot_var, state="readonly", width=5)
	slot_combo.pack(side="left", padx=5, pady=5)
	
	load_button = tk.Button(controls_frame, text="Load into entry", state="disabled", command=lambda: fill_entry_from_yml(structure_type, int(bg_slot_var.get()), slot_var.get(), text.get("1.0", "end-1c"), fields, check_vars))
	load_button.pack(side="left", padx=10, pady=5)
	
	def on_text_edit(event):
		nonlocal structure_type
		
		content = text.get("1.0", "end-1c")
	
		if validate_yml_structure(content, c.yml_bg_data):
			structure_type = c.BG_DATA
			status_label.config(text="Correct 'bg_data_table.yml' entry detected (select BG to load into).")
			bg_slot_combo["values"] = ("1", "2")
			bg_slot_var.set("1")
			slot_combo["values"] = ()
			slot_var.set("")
			load_button.config(state="normal")
		elif validate_yml_structure(content, c.yml_bg_scrolling):
			structure_type = c.BG_SCROLLING
			status_label.config(text="Correct 'bg_scrolling_table.yml' entry detected (select BG + entry to load into).")
			bg_slot_combo["values"] = ("1", "2")
			bg_slot_var.set("1")
			slot_combo["values"] = ("1", "2", "3", "4")
			slot_var.set("1")
			load_button.config(state="normal")
		elif validate_yml_structure(content, c.yml_bg_distortion):
			structure_type = c.BG_DISTORTION
			status_label.config(text="Correct 'bg_distortion_table.yml' entry detected (select BG + entry to load into).")
			bg_slot_combo["values"] = ("1", "2")
			bg_slot_var.set("1")
			slot_combo["values"] = ("1", "2", "3", "4")
			slot_var.set("1")
			load_button.config(state="normal")
		else:
			structure_type = None
			status_label.config(text="")
			bg_slot_combo["values"] = ()
			bg_slot_var.set("")
			slot_combo["values"] = ()
			slot_var.set("")
			load_button.config(state="disabled")
	
		text.edit_modified(False)
	
	text.bind("<<Modified>>", on_text_edit)
	
	return

# --------------------------------------------------------------------
# ----------------- Auxiliar YML validation function -----------------
# --------------------------------------------------------------------

# Validate entries from 'bg_data_table.yml'.

def validate_yml_structure(text, fields):
	lines = []
	
	for raw_line in text.splitlines():
		line = raw_line.split("#", 1)[0].rstrip()
		if line.strip():
			lines.append(line)
	
	if len(lines) != len(fields) + 1:
		return False
	
	if not lines[0].strip().endswith(":"):
		return False
	
	found_fields = []
	
	for line in lines[1:]:
		if ":" not in line:
			return False
		
		key = line.split(":", 1)[0].strip()
		found_fields.append(key)
	
	return found_fields == fields

# --------------------------------------------------------------------
# -------------------- Fill fields from YML text ---------------------
# --------------------------------------------------------------------
# ------------------- Again, not the best code... --------------------
# --------------------------------------------------------------------

def fill_entry_from_yml(structure_type, bg_entry, entry, text, fields, check_vars):
	
	if entry != "" and entry != None:
		entry = int(entry)
	
	lines = text.strip().splitlines()
	
	values = []
	
	for raw_line in lines[1:]:
		
		line = raw_line.split("#", 1)[0].rstrip()
		
		key, value = line.split(":", 1)
		values.append(value.strip())
	
	# Load into a 'Palettes' entry.
	
	if structure_type == c.BG_DATA:
		for idx, value in enumerate(values):
			if idx == 0:
				if bg_entry == 1:
					fields[c.m_field_names_palette[idx] + f"_bg{bg_entry}"].current(int(value) // 2 - 1)
			elif idx == 5:
				if value.isdigit():
					fields[c.m_field_names_palette[1] + f"_bg{bg_entry}"].current(value)
				else:
					fields[c.m_field_names_palette[1] + f"_bg{bg_entry}"].current(c.yml_cycle_type_names.index(value))
			elif idx > 5 and idx < 11:
				fields[c.m_field_names_palette[idx-4] + f"_bg{bg_entry}"].delete(0, tk.END)
				fields[c.m_field_names_palette[idx-4] + f"_bg{bg_entry}"].insert(0, value)
	
	# Load into a 'Scroll' entry.
	
	elif structure_type == c.BG_SCROLLING:
		
		check_vars[(bg_entry - 1)*8 + entry - 1].set(False)
		
		for idx, value in enumerate(values):
			fields[c.m_field_names_scroll[idx+1] + f"_bg{bg_entry}" + f"_scr{entry}"].delete(0, tk.END)
			fields[c.m_field_names_scroll[idx+1] + f"_bg{bg_entry}" + f"_scr{entry}"].insert(0, value)
	
	# Load into a 'Distortion' entry.
	
	elif structure_type == c.BG_DISTORTION:
		
		check_vars[(bg_entry - 1)*8 + entry + 3].set(False)
		
		for idx, value in enumerate(values):
			if idx < 4:
				fields[c.m_field_names_distortion[idx+2] + f"_bg{bg_entry}" + f"_dst{entry}"].delete(0, tk.END)
				fields[c.m_field_names_distortion[idx+2] + f"_bg{bg_entry}" + f"_dst{entry}"].insert(0, value)
			elif idx == 4:
				fields[c.m_field_names_distortion[7] + f"_bg{bg_entry}" + f"_dst{entry}"].delete(0, tk.END)
				fields[c.m_field_names_distortion[7] + f"_bg{bg_entry}" + f"_dst{entry}"].insert(0, value)
			elif idx == 5:
				if value.isdigit():
					fields[c.m_field_names_distortion[1] + f"_bg{bg_entry}" + f"_dst{entry}"].current(value)
				else:
					fields[c.m_field_names_distortion[1] + f"_bg{bg_entry}" + f"_dst{entry}"].current(c.yml_distortion_type_names.index(value))
			elif idx == 6:
				fields[c.m_field_names_distortion[10] + f"_bg{bg_entry}" + f"_dst{entry}"].delete(0, tk.END)
				fields[c.m_field_names_distortion[10] + f"_bg{bg_entry}" + f"_dst{entry}"].insert(0, value)
			elif idx == 7:
				fields[c.m_field_names_distortion[6] + f"_bg{bg_entry}" + f"_dst{entry}"].delete(0, tk.END)
				fields[c.m_field_names_distortion[6] + f"_bg{bg_entry}" + f"_dst{entry}"].insert(0, value)
			elif idx == 8:
				fields[c.m_field_names_distortion[8] + f"_bg{bg_entry}" + f"_dst{entry}"].delete(0, tk.END)
				fields[c.m_field_names_distortion[8] + f"_bg{bg_entry}" + f"_dst{entry}"].insert(0, value)
			elif idx == 9:
				fields[c.m_field_names_distortion[9] + f"_bg{bg_entry}" + f"_dst{entry}"].delete(0, tk.END)
				fields[c.m_field_names_distortion[9] + f"_bg{bg_entry}" + f"_dst{entry}"].insert(0, value)
	
	return

# --------------------------------------------------------------------
# ------------ Load from CoilSnake project (open window) -------------
# --------------------------------------------------------------------

def load_from_project_win(project_path, fields, check_vars, root):
	
	# Open new window.
	
	window = tk.Toplevel(root)
	
	try:
		base_path = sys._MEIPASS
	except Exception:
		base_path = os.path.abspath("assets")
	
	window.iconbitmap(os.path.join(base_path, "icon.ico"))
	
	window.title("Load from CoilSnake project")
	window.geometry(f"700x100+{root.winfo_x()+round(root.winfo_width()/2)-350}+{root.winfo_y()+round(root.winfo_height()/2)-50}")
	window.grab_set()
	
	window_top_frame = tk.Frame(window, height=20)
	window_top_frame.pack(side="top", fill="x")
	
	window_bottom_frame = tk.Frame(window, height=20)
	window_bottom_frame.pack(side="top", fill="x")
	
	container = tk.Frame(window_bottom_frame)
	container.pack(expand=True)
	
	label = tk.Label(window_top_frame, text="CoilSnake project directory:")
	label.grid(row=0, column=0, padx=5, pady=15, sticky="e")
	
	entry = tk.Entry(window_top_frame, textvariable=project_path)
	entry.grid(row=0, column=1, padx=5, pady=15, sticky="ew")
	
	button = tk.Button(window_top_frame, text="Browse", command=lambda: browse_directory(entry))
	button.grid(row=0, column=2, padx=10, pady=15)
	
	window_top_frame.grid_columnconfigure(1, weight=1)
	
	slot_combo = ttk.Combobox(container, values=[str(i) for i in range(327)], state="readonly", width=10)
	slot_combo.pack(side="left", padx=5, pady=5)
	slot_combo.current(0)
	
	button = tk.Button(container, text="Load into BG1", command=lambda: load_from_project(entry.get(), fields, check_vars, slot_combo.get(), 1))
	button.pack(side="left", padx=10, pady=5)
	
	button = tk.Button(container, text="Load into BG2", command=lambda: load_from_project(entry.get(), fields, check_vars, slot_combo.get(), 2))
	button.pack(side="left", padx=10, pady=5)
	
	return

# --------------------------------------------------------------------
# ---------------- Fill all fields from project data -----------------
# --------------------------------------------------------------------

def load_from_project(path, fields, check_vars, entry, layer):
	
	# Validate project folder.
	
	if not os.path.isdir(path):
		messagebox.showerror("Error", "Invalid project")
		return
	
	for filename in c.valid_project_files:
		if not os.path.isfile(os.path.join(path, filename)):
			messagebox.showerror("Error", "Invalid project")
			return
	
	# Fetch console.
	
	console = fields["console"]
	
	with open(os.path.join(path, "bg_data_table.yml"), encoding="utf-8") as f:
		bg_data_text = f.read()
	
	with open(os.path.join(path, "bg_scrolling_table.yml"), encoding="utf-8") as f:
		bg_scrolling_text = f.read()

	with open(os.path.join(path, "bg_distortion_table.yml"), encoding="utf-8") as f:
		bg_distortion_text = f.read()
	
	bg_entry_text = extract_yml_entry(bg_data_text, entry)
	
	if bg_entry_text == None:
		raise_error(console, 8)
		return
	
	# Load 'Palettes' entry.
	
	fill_entry_from_yml(c.BG_DATA, layer, None, bg_entry_text, fields, check_vars)
	
	# Extract values from entry
	
	lines = bg_entry_text.strip().splitlines()
	
	values = []
	
	for raw_line in lines[1:]:
		
		line = raw_line.split("#", 1)[0].rstrip()
		
		key, value = line.split(":", 1)
		values.append(value.strip())
	
	# Load 'Scroll' entries.
	
	for idx, scroll_id in enumerate([int(v) for v in values[11:15]]):
		scroll_entry_text = extract_yml_entry(bg_scrolling_text, scroll_id)
		
		if scroll_entry_text is None:
			raise_error(console, 8)
			return
		
		fill_entry_from_yml(c.BG_SCROLLING, layer, idx+1, scroll_entry_text, fields, check_vars)
		
		if scroll_id == 0:
			check_vars[(layer - 1)*8 + idx].set(True)
		else:
			check_vars[(layer - 1)*8 + idx].set(False)
	
	# Load 'Distortion' entries.
	
	for idx, distortion_id in enumerate([int(v) for v in values[1:5]]):
		distortion_entry_text = extract_yml_entry(bg_distortion_text, distortion_id)
		
		if distortion_entry_text is None:
			raise_error(console, 8)
			return
		
		fill_entry_from_yml(c.BG_DISTORTION, layer, idx+1, distortion_entry_text, fields, check_vars)
		
		if distortion_id == 0:
			check_vars[(layer - 1)*8 + idx + 4].set(True)
		else:
			check_vars[(layer - 1)*8 + idx + 4].set(False)
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Succesfully inserted project background " + f"{entry}" + " settings into BG" + f"{layer}.")
	console.config(state="disabled")
	
	return

# --------------------------------------------------------------------
# -------------- Auxiliar YML entry extraction function --------------
# --------------------------------------------------------------------

def extract_yml_entry(text, idx):
	
	lines = text.splitlines()
	
	block = []
	in_block = False
	
	for raw_line in lines:
		
		line = raw_line.split("#", 1)[0].rstrip()
		
		if line.strip() == f"{idx}:":
			in_block = True
			block.append(line)
			continue
		
		if in_block:
			if line.strip().endswith(":") and line.strip()[:-1].isdigit():
				break
			block.append(line)
	
	return "\n".join(block) if block else None

# --------------------------------------------------------------------
# ---------------------- Update images preview -----------------------
# --------------------------------------------------------------------

def update_preview(fields, img_frame_1, img_frame_2, *args):
	routes = [fields["setting_bg1"].get(), fields["setting_bg2"].get()]
	frames = [img_frame_1, img_frame_2]
	
	for i in range(2):
		for widget in frames[i].winfo_children():
			widget.destroy()
		
		if not routes[i]:
			tk.Label(frames[i], text="<NO IMG>").pack(expand=True)
			continue
		
		if not os.path.isfile(routes[i]):
			tk.Label(frames[i], text="<NOT FOUND>").pack(expand=True)
			continue
		
		try:
			img = Image.open(routes[i])
			img.thumbnail((128, 128))
			photo_img = ImageTk.PhotoImage(img)
			label_img = tk.Label(frames[i], image=photo_img)
			label_img.image = photo_img
			label_img.pack()
		except (UnidentifiedImageError, OSError):
			tk.Label(frames[i], text="<NOT FOUND>").pack(expand=True)

# --------------------------------------------------------------------
# --------------------------- Write to ROM ---------------------------
# --------------------------------------------------------------------

def execute(fields, check_vars):
	
	# Get base path and assets path.
	
	if getattr(sys, 'frozen', False):
		base_path = os.path.dirname(sys.executable)
	else:
		base_path = os.path.dirname(__file__)
	
	try:
		assets_path = sys._MEIPASS
	except Exception:
		assets_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "assets"))
	
	# Generate paths.
	
	img_1_out_path = os.path.join(base_path, c.TEMP_IMG_OUT_1)
	img_2_out_path = os.path.join(base_path, c.TEMP_IMG_OUT_2)
	img_out_paths = [img_1_out_path, img_2_out_path]
	
	img_1_out_gray_path = os.path.join(base_path, c.TEMP_IMG_OUT_GRAY_1)
	img_2_out_gray_path = os.path.join(base_path, c.TEMP_IMG_OUT_GRAY_2)
	img_out_gray_paths = [img_1_out_gray_path, img_2_out_gray_path]
	
	temp_palette_out_1_gray_path = os.path.join(base_path, c.TEMP_PALETTE_OUT_GRAY_1)
	temp_palette_out_1_path = os.path.join(base_path, c.TEMP_PALETTE_OUT_1)
	temp_tiles_out_1_path = os.path.join(base_path, c.TEMP_TILES_OUT_1)
	temp_tilemap_out_1_path = os.path.join(base_path, c.TEMP_TILEMAP_OUT_1)
	temp_bg1_data_out_paths = [temp_palette_out_1_path, temp_palette_out_1_gray_path, temp_tiles_out_1_path, temp_tilemap_out_1_path]
	
	temp_palette_out_2_gray_path = os.path.join(base_path, c.TEMP_PALETTE_OUT_GRAY_2)
	temp_palette_out_2_path = os.path.join(base_path, c.TEMP_PALETTE_OUT_2)
	temp_tiles_out_2_path = os.path.join(base_path, c.TEMP_TILES_OUT_2)
	temp_tilemap_out_2_path = os.path.join(base_path, c.TEMP_TILEMAP_OUT_2)
	temp_bg2_data_out_paths = [temp_palette_out_2_path, temp_palette_out_2_gray_path, temp_tiles_out_2_path, temp_tilemap_out_2_path]
	
	# Fetch files.
	
	route_rom = fields["setting_rom"].get()
	route_bg1 = fields["setting_bg1"].get()
	route_bg2 = fields["setting_bg2"].get()
	
	# Fetch console.
	
	console = fields["console"]
	
	# Validate ROM.
	
	# File doesn't exist.
	if not os.path.exists(route_rom):
		raise_error(console, 0)
		return
	
	# File too small.
	if os.path.getsize(route_rom) < 0x101CA:
		raise_error(console, 1)
		return
	
	# Raise error if the image for BG Layer 1 wasn't specified/doesn't exist.
	if not os.path.exists(route_bg1):
		raise_error(console, 2)
		return
	
	# Raise error if the image for BG Layer 2 was specified the file wasn't found.
	if route_bg2 != "" and not os.path.exists(route_bg2):
		raise_error(console, 3)
		return
	
	rom_info = (0x45, 0x41, 0x52, 0x54, 0x48, 0x20, 0x42, 0x4f, 0x55, 0x4E, 0x44)
	
	with open(route_rom, "r+b") as rom:
		header = 0x000
		
		rom.seek(0xFFC0)
		
		for byte in rom_info:
			if rom.read(1)[0] != byte:
				header = 0x200
				
				rom.seek(0xFFC0+header)
				
				for byte in rom_info:
					if rom.read(1)[0] != byte:
						raise_error(console, 1)
						return
		
		# Raise error if the enemy group is invalid.
		
		if int(fields[c.t_field_names[4]].get()) > c.MAX_ENEMY_GROUP:
			raise_error(console, 7)
			return
		
		# Give little warning that the ROM will be modified.
		
		rom.seek(0xC2FFFF - c.BANK_C0_OFFSET + header)
		
		if rom.read(1)[0] != 0xEA:
			if not messagebox.askokcancel("Warning", "The ROM will be modified to preview the battle background/s.\n\nContinue?"):
				raise_error(console, 5)
				return
		
		# Convert the images to the right BGR555 format.
		
		imgs = [Image.open(route_bg1)]
		
		if route_bg2 != "":
			imgs.append(Image.open(route_bg2))
		
		for idx, img in enumerate(imgs):
			if img.mode == 'P':
				pal = img.getpalette()
				new_pal = []
				
				for i in range(0, len(pal), 3):
					r = round_to_nearest_8(pal[i])
					g = round_to_nearest_8(pal[i+1])
					b = round_to_nearest_8(pal[i+2])
					new_pal.extend([r, g, b])
				
				img.putpalette(new_pal)
				img.save(img_out_paths[idx])
			
			else:
				raise_error(console, 6)
		
		# Make an alternative image in a gray scale to be used for superfamiconv tiles (dirty workaround).
		
		for idx, img in enumerate(imgs):
			if img.mode == 'P':
				pal = img.getpalette()
				num_colors = len(pal) // 3

				new_pal = []

				if num_colors == 1:
					gray = 255
					gray = round_to_nearest_8(gray)
					new_pal.extend([gray, gray, gray])
				else:
					for i in range(num_colors):
						t = i / (num_colors - 1)
						gray = int(255 * (1 - t))

						gray = round_to_nearest_8(gray)
						new_pal.extend([gray, gray, gray])

				img.putpalette(new_pal)
				img.save(img_out_gray_paths[idx])

			else:
				raise_error(console, 6)
		
		# Show an error message by default, you shouldn't see it if the process goes fine.
		
		raise_error(console, -1)
		
		# Run SuperFamiconV to extract data and Inhal to compress it and insert it.
		
		sfcv_path = os.path.join(assets_path, "superfamiconv")
		inhal_path = os.path.join(assets_path, "inhal")
		
		# Run SuperFamiconV for BG1.
		
		commands = [
			[sfcv_path, "palette", "-i", img_1_out_gray_path, "-d", temp_palette_out_1_gray_path, "-R", "-W", "8", "-H", "8"],
			[sfcv_path, "tiles", "-i", img_1_out_gray_path, "-d", temp_tiles_out_1_path, "-p", temp_palette_out_1_gray_path, "-B", fields["setting_bpp_bg1"].get(), "-W", "8", "-H", "8"],
			[sfcv_path, "map", "-i", img_1_out_gray_path, "-p", temp_palette_out_1_gray_path, "-t", temp_tiles_out_1_path, "-d", temp_tilemap_out_1_path, "-B", fields["setting_bpp_bg1"].get(), "-W", "8", "-H", "8"],
			[sfcv_path, "palette", "-i", img_1_out_path, "-d", temp_palette_out_1_path, "-R", "-W", "8", "-H", "8"],
		]
		
		for command in commands:
			result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
			
			# If there was a SuperFamiconV error, show it through the console.
			
			if result.returncode != 0:
				console.config(state="normal")
				console.delete("1.0", "end")
				console.insert("1.0", "[!] Trying to insert a 2BPP layer when the image is 4BPP?\n" + f"[!] SuperFamiconV: {result.stderr}")
				console.config(state="disabled")
				return
		
		# Insert palette in ROM.
		
		with open(temp_palette_out_1_path, "rb") as f:
			pal_data = f.read()
		
		rom.seek(c.PAL_25_OFFSET - c.BANK_C0_OFFSET + header)
		rom.write(pal_data)
		
		# Compress tiles and tilemap with Inhal and insert them.
		
		commands = [
			[inhal_path, "-fast", temp_tiles_out_1_path, route_rom, f"{c.GFX_25_OFFSET - c.BANK_C0_OFFSET + header}"],
			[inhal_path, "-fast", temp_tilemap_out_1_path, route_rom, f"{c.ARR_25_OFFSET - c.BANK_C0_OFFSET + header}"]
		]
		
		for command in commands:
			result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
			
			if result.returncode != 0:
				console.config(state="normal")
				console.delete("1.0", "end")
				console.insert("1.0", f"[!] Inhal: {result.stderr}")
				console.config(state="disabled")
				return
		
		# If there is a BG2 image, do the same for BG2.
		
		if route_bg2 != "":
			commands = [
				[sfcv_path, "palette", "-i", img_2_out_gray_path, "-d", temp_palette_out_2_gray_path, "-R", "-W", "8", "-H", "8"],
				[sfcv_path, "tiles", "-i", img_2_out_gray_path, "-d", temp_tiles_out_2_path, "-p", temp_palette_out_2_gray_path, "-B", fields["setting_bpp_bg2"].get(), "-W", "8", "-H", "8"],
				[sfcv_path, "map", "-i", img_2_out_gray_path, "-p", temp_palette_out_2_gray_path, "-t", temp_tiles_out_2_path, "-d", temp_tilemap_out_2_path, "-B", fields["setting_bpp_bg2"].get(), "-W", "8", "-H", "8"],
				[sfcv_path, "palette", "-i", img_2_out_path, "-d", temp_palette_out_2_path, "-R", "-W", "8", "-H", "8"],
			]
			
			for command in commands:
				result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
				
				# If there was a SuperFamiconV error, show it through the console.
				
				if result.returncode != 0:
					console.config(state="normal")
					console.delete("1.0", "end")
					console.insert("1.0", "[!] Trying to insert a 2BPP layer when the image is 4BPP?\n" + f"[!] SuperFamiconV: {result.stderr}")
					console.config(state="disabled")
					return
			
			# Insert palette in ROM.
		
			with open(temp_palette_out_2_path, "rb") as f:
				pal_data = f.read()
			
			rom.seek(c.PAL_50_OFFSET - c.BANK_C0_OFFSET + header)
			rom.write(pal_data)
			
			# Compress tiles and tilemap with Inhal and insert them.
			
			commands = [
				[inhal_path, "-fast", temp_tiles_out_2_path, route_rom, f"{c.GFX_50_OFFSET - c.BANK_C0_OFFSET + header}"],
				[inhal_path, "-fast", temp_tilemap_out_2_path, route_rom, f"{c.ARR_50_OFFSET - c.BANK_C0_OFFSET + header}"]
			]
			
			for command in commands:
				result = subprocess.run(command, capture_output=True, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
				
				if result.returncode != 0:
					console.config(state="normal")
					console.delete("1.0", "end")
					console.insert("1.0", f"[!] Inhal: {result.stderr}")
					console.config(state="disabled")
					return
		
		# Insert forced bytes.
		
		for insertion in c.forced_rom_insertions:
			rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
			rom.write(bytes(insertion["bytes"]))
		
		# Insert dynamic data.
		
		for insertion in c.dynamic_rom_insertions:
			if insertion["pointer_type"] == "dp":
				pointer_address = insertion["pointer_address"]
				
				rom.seek(pointer_address - c.BANK_C0_OFFSET + header)
				block = rom.read(7)
				
				address = ((block[6] << 16) | (block[2] << 8) | block[1]) + insertion["insertion_offset"]
				
				rom.seek(address - c.BANK_C0_OFFSET + header)
				rom.write(bytes(insertion["bytes"]))
		
		# Insert enemy group to load.
		
		d = struct.pack("<H", int(fields[c.t_field_names[4]].get()))
		
		rom.seek(0xC4DB4E - c.BANK_C0_OFFSET + header)
		rom.write(d)
		
		if route_bg2 == "":
			
			# If there is no BG2, don't load it.
			
			rom.seek(c.MENU_BG2_OFFSET - c.BANK_C0_OFFSET + header)
			rom.write(bytes([0x00]))
			
			# Don't use it in battle either.
			
			rom.seek(0xC248BE - c.BANK_C0_OFFSET + header)
			rom.write(bytes([0x00, 0x00]))
		
		# Insert palette cycling settings.
		
		# Assume every setting should be a byte.
		
		for insertion in c.insertions_palette:
			if insertion["field"] == "combobox_idx":
				d = bytes([int(c.CYCLE_TYPE_NAMES.index(fields[insertion["name"]].get()))])
			else:
				d = bytes([int(fields[insertion["name"]].get())])
			
			rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
			rom.write(d)
		
		# Zero out scroll and distortion entries if the boxes are checked.
		
		i = 0
		
		for insertion in c.insertions_check:
			if check_vars[i].get():
				rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header)
				rom.write(bytes([0x00]))
				
			# Advance in the 'check_vars' list.
			i = i + 1
	
		# Insert scroll entry settings.
		
		# Assume every setting should be fetched from an entry and have a 'short' data type.
		
		for bg in range(2):
			for scr in range(4):
				for insertion in c.insertions_scroll:
					d = struct.pack("<H", int(fields[insertion["name"] + f"_bg{bg+1}_scr{scr+1}"].get()))
					
					rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header + bg*c.SCR_ENTRY_SIZE*4 + scr*c.SCR_ENTRY_SIZE)
					rom.write(d)
	
		# Insert distortion entry settings.
		
		for bg in range(2):
			for dst in range(4):
				for insertion in c.insertions_distortion:
					if insertion["field"] == "combobox_idx":
						# Assume 'byte' data type.
						d = bytes([int(c.DST_TYPE_NAMES.index(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get()))])
					else:
						# Assume 'entry' field type.
						if insertion["type"] == "byte":
							d = bytes([int(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get())])
						else:
							#  Assume 'short' data type.
							d = struct.pack("<H", int(fields[insertion["name"] + f"_bg{bg+1}_dst{dst+1}"].get()))
					
					rom.seek(insertion["offset"] - c.BANK_C0_OFFSET + header + bg*c.DST_ENTRY_SIZE*4 + dst*c.DST_ENTRY_SIZE)
					rom.write(d)
	
	# Delete all temporary files.
	
	os.remove(img_1_out_path)
	os.remove(img_1_out_gray_path)
	
	for file in temp_bg1_data_out_paths:
		os.remove(file)
	
	if os.path.exists(img_2_out_path):
		os.remove(img_2_out_path)
		os.remove(img_2_out_gray_path)
		
		for file in temp_bg2_data_out_paths:
			if os.path.exists(file):
				os.remove(file)
	
	# Show success in console.
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Execution finished succesfully.")
	console.config(state="disabled")
	
	return

# --------------------------------------------------------------------
# -------------------------- Try to run ROM --------------------------
# --------------------------------------------------------------------

def run_rom(fields):
	
	# Fetch emulator and ROM.
	
	route_emulator = fields["setting_emulator"].get()
	route_rom = fields["setting_rom"].get()
	
	# Fetch console.
	
	console = fields["console"]
	
	if route_emulator == "" or not os.path.exists(route_emulator):
		raise_error(console, 4)
		return
	
	# ROM file doesn't exist.
	if not os.path.exists(route_rom):
		raise_error(console, 0)
		return
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[o] Attempting to run the ROM.\n[o] Hold Y in-game to pause the animation, press L to switch between letterbox sizes. Press Start to preview a battle against the specified enemy group.")
	console.config(state="disabled")
	Popen([route_emulator, route_rom])
	
	return

# --------------------------------------------------------------------
# ----------------------- Auxiliary functions ------------------------
# --------------------------------------------------------------------

# ------------------------ Round to nearest 8 ------------------------

def round_to_nearest_8(value):
    rounded = round(value / 8) * 8
    return max(0, min(255, rounded))

# -------------------------- Error handler ---------------------------

def raise_error(console, code):
	if code == 0:
		msg = "The specified ROM file doesn't exist."
	elif code == 1:
		msg = "The ROM file does not seem to be a valid EarthBound ROM."
	elif code == 2:
		msg = "The specified image file for the first layer was not found"
	elif code == 3:
		msg = "The specified image file for the second layer was not found"
	elif code == 4:
		msg = "An emulator couldn't be found."
	elif code == 5:
		msg = "The execution was aborted."
	elif code == 6:
		msg = "One or more of the specified image files isn't in indexed palette mode."
	elif code == 7:
		msg = "The specified enemy group exceeds the vanilla maximum (483)."
	elif code == 8:
		msg = "One or more of the YML entries in the Project has a wrong format."
	else:
		msg = "An unknown exception occured (check field values or try again)."
	
	console.config(state="normal")
	console.delete("1.0", "end")
	console.insert("1.0", "[!] " + msg)
	console.config(state="disabled")
	
	return